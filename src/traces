   0x8049db5 <readString>:      push   %ebp		#Create stack for readString function
   0x8049db6 <readString+1>:    mov    %esp,%ebp	#^
   0x8049db8 <readString+3>:    sub    $0x38,%esp	#char buf[BUFSIZE]
   0x8049dbb <readString+6>:    movl   $0x0,-0xc(%ebp)	#i=0
   0x8049dc2 <readString+13>:   mov    0x80e3434,%eax	#While(1)
   0x8049dc7 <readString+18>:   sub    $0xc,%esp	#Allocate space for local variables
   0x8049dca <readString+21>:   push   %eax		#Push register eax in stack
   0x8049dcb <readString+22>:   call   0x8059530 <getc>	#fgetc(stdin)
   0x8049dd0 <readString+27>:   add    $0x10,%esp	#Deallocate space from stack
   0x8049dd3 <readString+30>:   mov    %eax,-0x10(%ebp)	#Move value of eax in address ebp-0x10
   0x8049dd6 <readString+33>:   cmpl   $0xffffffff,-0x10(%ebp)		#if c == EOF
   0x8049dda <readString+37>:   je     0x8049df4 <readString+63>	#If statement(false)
   0x8049ddc <readString+39>:   cmpl   $0xa,-0x10(%ebp)			#if c == 'n'
   0x8049de0 <readString+43>:   je     0x8049df4 <readString+63>	#If statement(false)
   0x8049de2 <readString+45>:   mov    -0xc(%ebp),%eax			#prepare for buf[i++]=c
   0x8049de5 <readString+48>:   lea    0x1(%eax),%edx			#^
   0x8049de8 <readString+51>:   mov    %edx,-0xc(%ebp)			#^
   0x8049deb <readString+54>:   mov    -0x10(%ebp),%edx			#^
   0x8049dee <readString+57>:   mov    %dl,-0x2e(%ebp,%eax,1)		#buf[i++] = c
   0x8049df2 <readString+61>:   jmp    0x8049dc2 <readString+13>	#Loop around
   0x8049df4 <readString+63>:   lea    -0x2e(%ebp),%edx			#ebp-0x2e = edx
   0x8049df7 <readString+66>:   mov    -0xc(%ebp),%eax			#ebp-0xc = eax
   0x8049dfa <readString+69>:   add    %edx,%eax			#edx += eax
   0x8049dfc <readString+71>:   movb   $0x0,(%eax)	#buf[i] = 0
   0x8049dff <readString+74>:   movl   $0x0,-0xc(%ebp)	#i = 0 
   0x8049e06 <readString+81>:   jmp    0x8049e21 <readString+108> #if i>=BUFSIZE dont go in for
   0x8049e08 <readString+83>:   mov    -0xc(%ebp),%edx	#for loop
   0x8049e0b <readString+86>:   mov    0x8(%ebp),%eax	#^
   0x8049e0e <readString+89>:   add    %eax,%edx	#^
   0x8049e10 <readString+91>:   lea    -0x2e(%ebp),%ecx	#^
   0x8049e13 <readString+94>:   mov    -0xc(%ebp),%eax	#^
   0x8049e16 <readString+97>:   add    %ecx,%eax	#^
   0x8049e18 <readString+99>:   movzbl (%eax),%eax	#s[i] = buf[i]
   0x8049e1b <readString+102>:  mov    %al,(%edx)		 #prepare for condition
   0x8049e1d <readString+104>:  addl   $0x1,-0xc(%ebp)		 #prepare for condition
   0x8049e21 <readString+108>:  cmpl   $0x1d,-0xc(%ebp)		 #i < BUFSIZE
   0x8049e25 <readString+112>:  jle    0x8049e08 <readString+83> #if cond. was true loop around
   0x8049e27 <readString+114>:  nop	#no operation
   0x8049e28 <readString+115>:  leave	#leave from stack
   0x8049e29 <readString+116>:  ret	#return


Data segment:
	&grade = 0x80e3068 
	grade = 3
Bss segment:
	&Name = 0x80e42dc
Stack-frame:
	$esp = 0xbffff440
	$ebp = 0xbffff478
	x/56b $esp

	-----------------------------------------------------------------
	|	(esp+0b) 0xbffff440 => $esp				|
	|	(esp+10b)0xbffff44a => buf[30]				|
	|	(esp+40b)0xbffff468 => c				|
	|	(esp+44b)0xbffff46c => i = 0				|
	|	(esp+60b)0xbffff47C => Return Address = 0x8049e72	|
	|	(esp+64b)0xbffff480 => &s = Name = 0x80e42dc		|
	-----------------------------------------------------------------

